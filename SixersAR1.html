<!DOCTYPE html>
<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>SixersAR</title>
	<!-- include three.js library -->
	<script src='js/three.js'></script>
	<script src='js/FBXLoader.js'></script>
	<script src='js/inflate.min.js'></script>
	<script src='js/OrbitControls.js'></script>
	<script src='js/FBXLoader.js'></script>
	<script src="js/stats.min.js"></script>
	<script src="js/curves/NURBSCurve.js"></script>
	<script src="js/curves/NURBSUtils.js"></script>

	<!-- include jsartookit -->
	<script src="jsartoolkit5/artoolkit.min.js"></script>
	<script src="jsartoolkit5/artoolkit.api.js"></script>
	<!-- include threex.artoolkit -->
	<script src="threex/threex-artoolkitsource.js"></script>
	<script src="threex/threex-artoolkitcontext.js"></script>
	<script src="threex/threex-arbasecontrols.js"></script>
	<script src="threex/threex-armarkercontrols.js"></script>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>

<img src="images/main.png" id="main" style="width: 100%; height: 100%" />
<img src="images/scan.png" id="scan" />
<img src="images/init.png" id="init" />

<button onclick="myFunction()">Click Me</button>

<script>

var scene, camera, renderer, light;

var arToolkitSource, arToolkitContext;

var markerNames, markerArray, currentMarkerName;

var objectArray;

var previousrot=[]; 
var previouspos=[]; 

var clock = new THREE.Clock();

var mixers = [];

var CurObjIndex;

initialize();
animate();

function initialize()
{
	container = document.createElement( 'div' );
	document.body.appendChild( container );

//	document.getElementById("scan").requestFullscreen();

	document.getElementById("scan").style.visibility = "hidden";
	document.getElementById("init").style.visibility = "hidden";

	scene = new THREE.Scene();

	light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
	light.position.set( 0, 200, 0 );
	scene.add( light );

	light = new THREE.DirectionalLight( 0xffffff );
	light.position.set( 0, 200, 100 );
	light.castShadow = true;
	light.shadow.camera.top = 180;
	light.shadow.camera.bottom = - 100;
	light.shadow.camera.left = - 120;
	light.shadow.camera.right = 120;
	scene.add( light );
				
	camera = new THREE.Camera();
	scene.add(camera);

	renderer = new THREE.WebGLRenderer({
		antialias : true,
		alpha: true
	});

	renderer.setClearColor(new THREE.Color('lightgrey'), 0)

	renderer.setPixelRatio( window.devicePixelRatio );

	renderer.setSize( 800, 600 );

	renderer.shadowMap.enabled = true;

	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild( renderer.domElement);

	clock = new THREE.Clock();
	deltaTime = 0;
	totalTime = 0;
	
	////////////////////////////////////////////////////////////
	// setup arToolkitSource
	////////////////////////////////////////////////////////////

	arToolkitSource = new THREEx.ArToolkitSource({
		sourceType : 'webcam',
	});

	function onResize()
	{
		arToolkitSource.onResize()	
		arToolkitSource.copySizeTo(renderer.domElement)	
		if ( arToolkitContext.arController !== null )
		{
			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
		}	
	}

	arToolkitSource.init(function onReady(){
		onResize()
	});
	
	// handle resize event
	window.addEventListener('resize', function(){
		onResize()
	});
	
	////////////////////////////////////////////////////////////
	// setup arToolkitContext
	////////////////////////////////////////////////////////////	

	// create atToolkitContext
	arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: 'data/camera_para.dat',
		detectionMode: 'mono'
	});
	
	// copy projection matrix to camera when initialization complete
	arToolkitContext.init( function onCompleted(){
		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
	});

	////////////////////////////////////////////////////////////
	// setup markerRoots
	////////////////////////////////////////////////////////////

	// build markerControls
	markerNames = ["01", "02", "03", "04"];
	
	markerArray = [];
	objectArray = [];

	for (let i = 0; i < markerNames.length; i++)
	{
		let marker = new THREE.Group();
		scene.add(marker);
		markerArray.push(marker);
		
		let markerControls = new THREEx.ArMarkerControls(arToolkitContext, marker, {
			type: 'pattern', patternUrl: "data/" + markerNames[i] + ".patt",
		});
	}

	function onProgress(xhr) { console.log( (xhr.loaded / xhr.total * 100) + '% loaded' ); }
	function onError(xhr) { console.log( 'An error happened' ); }

	// model

	var loader1 = new THREE.FBXLoader();
	loader1.load( 'models/Healy.fbx', function ( object ) {

		object.scale.setScalar(0.007);
		object.position.set(0, 0, 0); 

		object.mixer = new THREE.AnimationMixer( object );
		mixers.push( object.mixer );

		var action = object.mixer.clipAction( object.animations[ 0 ] );
		action.play();

		markerArray[0].add( object );

		objectArray[0] = object;

		CurObjIndex = 0;

	} , onProgress, onError);

	// model
	var loader2 = new THREE.FBXLoader();
	loader2.load( 'models/HP.fbx', function ( object ) {

		object.scale.setScalar(0.005);
        object.position.set(-0.4, 0, 0.15); 

		markerArray[1].add( object );

		objectArray[1] = object;

	} , onProgress, onError);

	// model
	var loader3 = new THREE.FBXLoader();
	loader3.load( 'models/Maddinson.fbx', function ( object ) {

		object.scale.setScalar(0.007);
        object.position.set(0, 0, 0); 

		markerArray[2].add( object );

		objectArray[2] = object;

	} , onProgress, onError);

	// model
	var loader4 = new THREE.FBXLoader();
	loader4.load( 'models/Syd.fbx', function ( object ) {

		object.scale.setScalar(0.004);
        object.position.set(0, 0, 0); 

		markerArray[3].add( object );

		objectArray[3] = object;

	} , onProgress, onError);

	currentMarkerName = markerNames[0];
}

function update()
{
	let anyMarkerVisible = false;
	for (let i = 0; i < markerArray.length; i++)
	{
		if ( markerArray[i].visible )
		{
			anyMarkerVisible = true;
			if ( currentMarkerName != markerNames[i] )
			{
				currentMarkerName = markerNames[i];
				mixers = [];

				objectArray[i].mixer = new THREE.AnimationMixer( objectArray[i] );
	            CurObjIndex = i;
				mixers.push( objectArray[i].mixer );
				var action = objectArray[i].mixer.clipAction( objectArray[i].animations[ 0 ] );
				action.play();
			}

			document.getElementById("scan").style.visibility = "hidden";

			document.getElementById("init").style.visibility = "visible";
//			$("#init").fadeOut(1000);

			break;
		}
	}

	if (objectArray[0] && !anyMarkerVisible )
	{
		document.getElementById("scan").style.visibility = "visible";
	}

	if(objectArray[CurObjIndex])
	{
		var pos = markerArray[CurObjIndex].position;
		var rot = markerArray[CurObjIndex].rotation;

		if(pos != {x:0,y:0,z:0})
		{
			markerArray[CurObjIndex].position.set(0, 0, 0); 
		}
		if(rot != {x:0,y:0,z:0})
		{
			markerArray[CurObjIndex].rotation.set(0, 0, 0);
		}

		// previousrot.push({x:0,y:0,z:0}); 
		// previouspos.push({x:0,y:0,z:0}); 

		// 		previousrot[CurObjIndex].z=(previousrot[CurObjIndex].z+markerArray[CurObjIndex].rotation.z)/2; 
		// 	previousrot[CurObjIndex].x=(previousrot[CurObjIndex].x+markerArray[CurObjIndex].rotation.x)/2; 
		// 	previousrot[CurObjIndex].y=(previousrot[CurObjIndex].y+markerArray[CurObjIndex].rotation.y)/2;

		// 	markerArray[CurObjIndex].rotation.set(previousrot[CurObjIndex].x,previousrot[CurObjIndex].y,previousrot[CurObjIndex].z); 

		// 	previouspos[CurObjIndex].x=(previouspos[CurObjIndex].x+markerArray[CurObjIndex].position.x)/2; 
		// 	previouspos[CurObjIndex].y=(previouspos[CurObjIndex].y+markerArray[CurObjIndex].position.y)/2; 
		// 	previouspos[CurObjIndex].z=(previouspos[CurObjIndex].z+markerArray[CurObjIndex].position.z)/2; 

		// 	markerArray[CurObjIndex].position.set(previouspos[CurObjIndex].x,previouspos[CurObjIndex].y,previouspos[CurObjIndex].z);

		// 	markerArray[CurObjIndex].updateMatrix(); 

	}

	// update artoolkit on every frame
	if ( arToolkitSource.ready !== false )
		arToolkitContext.update( arToolkitSource.domElement );
}

function animate()
{
	requestAnimationFrame( animate );
	if ( mixers.length > 0 ) {
		for ( var i = 0; i < mixers.length; i ++ ) {
			mixers[ i ].update( clock.getDelta() );
		}
	}

	update();

	renderer.render( scene, camera );
}

// Detach the Tracks from the DOM.
function detachTracks(tracks) {
  let isSafari = /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);
  tracks.forEach(function(track) {
    if (isSafari) {
      track._attachments.forEach(function(element) {
        element.remove();
      });
    } else {
      track.detach().forEach(function(detachedElement) {
        detachedElement.remove();
      });
    }
  });
}

function setImageVisible(id, visible) {
    var img = document.getElementById(id);
    img.style.visibility = (visible ? 'visible' : 'hidden');
}

</script>
</body>
</html>